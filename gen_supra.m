function [u,i] = gen_supra(cfg, N)
% Generates supra-harmonic content using model generated by 'supra.m'.
%
% usage: 
%   [u,i] = gen_supra(cfg, N);
%
% inputs:
%   cfg.fs - sampling rate [Hz]
%   cfg.supra_fmin - lower freq limit of generated content [Hz]
%   cfg.supra_fmax - upper freq limit of generated content [Hz]
%   cfg.supra_slice_N or cfg.supra_slice_t: 
%     - optional, generates waves per slices of given sample count or time slice (not both)
%     - use this to simulate spread spectrum/fluctuation harmonics
%     - do not assign to disable
%   cfg.supra_multi_spur - generate multiple spurs with randomized frequency for each slice
%                          (another way of simulating spread spectrum/fluctuations)
%   cfg.supra_model - model file of supra-harmonics generated by 'supra.m'
%   cfg.supra_imp_model, model file of grid impedance generate by 'grimp.m'
%   cfg.supra_imp_Rs, cfg.supra_imp_Ls and cfg.supra_imp_Cp:
%     - alternative to cfg.supra_imp_model if not provided 
%     - crude model of grid impedance to calculate current spectrum from voltage spectrum
%     - uses equivalent circuit: (Rs+Ls) || Cp
%   
%   N - simulated wave length
%   
% returns:
%   u - voltage waveform having N samples
%   i - current waveform having N samples
%
% This is part of the EVCS charging waveform simulator.
% Developed in scope of EPM project 23IND06 Met4EVCS: https://www.vsl.nl/en/met4evcs/
% Source: https://github.com/smaslan/sim-met4evcs
% (c) 2025, Stanislav Maslan (smaslan@cmi.cz)
% The script is distributed under MIT license, https://opensource.org/licenses/MIT.

    % load supraharmoncis model file
    model = load(cfg.supra_model);
    model = model.model;
    
    % smoothed overlapping of slices
    slice_overlap = 200;
       
    % generate waves per slices:
    u = zeros(N,1);
    i = zeros(N,1);
    n = 0;
    while n < N
    
        %n
                    
        if cfg.supra_slice_N
        
            % multiple slices        
            if N - n >= 2*cfg.supra_slice_N;
                
                N_slice = cfg.supra_slice_N;                
                if n > 0
                    window = [linspace(0,1,slice_overlap).';ones([N_slice-2*slice_overlap 1]);linspace(1,0,slice_overlap).'];                    
                else
                    window = [ones([N_slice-slice_overlap 1]);linspace(1,0,slice_overlap).'];                    
                end                
                n_step = N_slice - slice_overlap;
                
            else
                % expand last slice if shorter than desired slice size
                N_slice = N - n;
                window = [linspace(0,1,slice_overlap).';ones([N_slice-slice_overlap 1])];
                n_step = N_slice;
                
            end
                    
        else
            % signle slice mode
            N_slice = N;
            window = ones([N_slice 1]);
            n_step = N_slice;
                        
        end           
        
        % model sample count
        N_sim = ceil(N_slice/2)*2; % always even sample count, at the end will be reduced to desired count
        % model sampling rate [Hz]
        fs_sim = cfg.fs;
        % model freq limits [Hz]
        f_sim_max = min(cfg.supra_fmax, fs_sim/2);
        f_sim_min = cfg.supra_fmin;
        
        % model freq axis
        f_sim = [];
        f_sim(:,1) = [0:N_sim/2]/N_sim*fs_sim;
        f_step = diff(f_sim(1:2));
        f_mask = (f_sim >= f_sim_min & f_sim <= f_sim_max);
        f_mask(1) = 0; % no DC spot
        f_mask(end) = 0; % no nyquist spot
        
        % prepare noise levels       
        noise_f = f_sim;
        noise_amp = interp1(model.noise_f,model.noise_a_med, noise_f, 'linear', 'extrap');
        noise_max = interp1(model.noise_f,model.noise_a_max, noise_f, 'linear', 'extrap');
        noise_min = interp1(model.noise_f,model.noise_a_min, noise_f, 'linear', 'extrap');
        noise_std = (noise_max - noise_amp);
    
        % generate noise
        U_sim = max(noise_amp + noise_std.*2.*(rand(size(noise_f)) - 0.5), noise_min);    
        
        % now generate spurs with randomized frequencies corresponding to model freq resolution
        for k = 1:cfg.supra_multi_spur
            
            % generate spurs
            spur_a = model.spur_a;
            spur_f = rand2(size(model.spur_f),model.spur_f,model.spur_uf);
            
            % limit spurs to desired f range
            spur_a = spur_a(spur_f >= f_sim_min & spur_f <= f_sim_max - f_step);
            spur_f = spur_f(spur_f >= f_sim_min & spur_f <= f_sim_max - f_step);                
            spur_bin = round(spur_f/f_step);
             
            % place'em to image 
            U_sim(spur_bin) = spur_a;
            
        end              
        
        % generate random phase angles
        U_sim = U_sim.*exp(j*rand(size(U_sim))*2*pi);              
        
%         figure
%         semilogy(f_sim, abs(amp_sim))       
        
        % mask bins
        U_sim = U_sim.*f_mask;
        
        % load/make model of grid impedance    
        if isfield(cfg,'supra_imp_model')
            % load from model file            
            grimp_model = load(cfg.supra_imp_model);
            grimp_model = grimp_model.model;            
            Z = interp1(grimp_model.f, grimp_model.Z, f_sim, 'linear', 'extrap');
                     
        else
            % generate from simple model: (Rs+Ls) || Cp
            w = 2*pi*f_sim;
            Z = 1./(1./(cfg.supra_imp_Rs + j*w*cfg.supra_imp_Ls) + j*w*cfg.supra_imp_Cp);
            
        end
        
        % make current estimate from voltage and grid impedance (very crude solution)
        I_sim = U_sim./Z;
        
        % mirror simulated spectrum to negative frequencies to complete the FFT image
        U_sim = [U_sim;conj(U_sim(end-1:-1:2))];
        I_sim = [I_sim;conj(I_sim(end-1:-1:2))];
        
        % synthesize wave    
        u_wave = real(ifft(U_sim))*N_slice/2;
        u_wave = u_wave(1:N_slice); % trunc to desired size
        i_wave = real(ifft(I_sim))*N_slice/2;
        i_wave = i_wave(1:N_slice); % trunc to desired size
        
        % store to output wave
        u(n+1:n+N_slice,1) = u(n+1:n+N_slice,1) + u_wave.*window;
        i(n+1:n+N_slice,1) = i(n+1:n+N_slice,1) + i_wave.*window;
        
        % to next slice
        n = n + n_step;
    
    end % for each slice

end